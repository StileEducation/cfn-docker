#!/usr/bin/env python

import os
import logging
import argparse
import boto.utils
import docker
import subprocess
import json
import urllib2
from tsort import topological_sort

CONFIG_DIR = '/var/lib/cfn-docker'
METADATA_FILE = CONFIG_DIR + '/metadata.json'
logger = logging.getLogger('cfn-docker')

docker_client = docker.Client()

def main():
    logging.basicConfig(level=logging.INFO)

    if not os.path.isdir(CONFIG_DIR):
        os.mkdir(CONFIG_DIR)

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    fetch_parser = subparsers.add_parser('fetch', help='Fetch configuration from CloudFormation metadata')
    fetch_parser.set_defaults(func=fetch)
    fetch_parser.add_argument('--stack-name', required=True, help="CloudFormation stack name")
    fetch_parser.add_argument('--resource-name', required=True, help="CloudFormation resource in stack")

    up_parser = subparsers.add_parser('up', help='Ensure all containers in the fetched CloudFormation metadata are running')
    up_parser.add_argument('--container', '-c', help="Only a specific container, rather than all known container types")
    up_parser.add_argument('--restart', '-r', action='store_true', help="Force restart container(s)")
    up_parser.set_defaults(func=up)

    run_parser = subparsers.add_parser('run', help='Ensure all containers in the fetched CloudFormation metadata are running')
    run_parser.add_argument('--container', '-c', help="Container type to execute command in.")
    run_parser.add_argument('--command', help="Command to pass to the container")
    run_parser.set_defaults(func=run)

    # Parse arguments and run selected subcommand.
    # Subcommands register their main function in argparse as a default for `func`.
    args = parser.parse_args()
    args.func(args)

def fetch(args):
    instance_metadata = boto.utils.get_instance_metadata()
    region = instance_metadata['placement']['availability-zone'][:-1]   # TODO: feels hacky

    # Call out to cfn-get-metadata instead of using boto because it uses special CFN authentication
    # that requires no credentials.
    out, err = subprocess.Popen(['/opt/aws/bin/cfn-get-metadata',
        '--region', region,
        '-s', args.stack_name,
        '-r', args.resource_name,
        '-k', 'Docker'], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
    # TODO: check exit code

    # Parse and write out metdata
    docker_metadata = json.loads(out)
    # TODO: validate schema
    with open(METADATA_FILE, 'w') as f:
        f.write(json.dumps(docker_metadata, indent=4))

def up(args):
    with open(METADATA_FILE, 'r') as f:
        docker_metadata = json.load(f)

    # Look for special environment variable functions
    for container in docker_metadata.get('containers', {}).values():

        for key, value in container.get('environment', {}).items():
            if type(value) is dict and len(value) == 1:
                container['environment'][key] = env_function(value)

        # There are also environemnts in the prestarts, so look there too.
        for beforeStart in container.get('beforeStart' , []):

            for key, value in beforeStart.get('environment', {}).items():
                if type(value) is dict and len(value) == 1:
                    beforeStart['environment'][key] = env_function(value)

    if args.container:
        config = docker_metadata['containers'].get(args.container)
        if config:
            run_single(args.container, config, args.restart)
        else:
            logger.info('Could not find container type %s' % (args.container))

    else:
        for name, config in dependency_sort(docker_metadata['containers']):
            run_single(name, config, args.restart)

def run(args):
    with open(METADATA_FILE, 'r') as f:
        docker_metadata = json.load(f)

    config = docker_metadata['containers'].get(args.container)
    if config:
        ensure_image(config['image'])

        # Substitute environment variables
        for key, value in config.get('environment', {}).items():
            if type(value) is dict and len(value) == 1:
                config['environment'][key] = env_function(value)

        command = ['/usr/bin/docker', 'run', '-t', '-i']

        for k, v in config.get('environment', {}).iteritems():
            command.append('-e')
            command.append("%s=%s" % (k ,v))

        command.append(config['image'])
        command.append(args.command)

        logger.info('Launching %s with command %s' % (args.container, args.command))
        subprocess.call(command)
    else:
        logger.info('Could not find container type %s' % (args.container))


def run_single(name, config, restart=False):
    ensure_image(config['image'])

    if container_exists(name) and configuration_changed(name, config):
        logger.info('Configuration has changed. Removing container %s' % (name))
        if container_running(name):
            docker_client.kill(name)
        docker_client.remove_container(name)


    if not container_exists(name):

        # Run any commands that need to happen before the container starts
        for beforeStart in config.get('beforeStart', []):
            logger.info('Running %s beforeStart for command %s' % (name, beforeStart.get('command', "")))

            # The beforeStart environment is also has the normal container environment
            beforeStartEnvironment = dict(config['environment'].items() + beforeStart['environment'].items())
            container_name = "%s-pre" % (name)

            docker_client.create_container(config['image'], name=container_name, environment=beforeStartEnvironment, command=beforeStart.get('command', None))
            docker_client.start(container_name, binds=config.get('volumes', None), port_bindings=config.get('ports', None), links=None)
            exit_code = docker_client.wait(container_name)
            logger.info(docker_client.logs(container_name))
            docker_client.remove_container(container_name)

        logger.info('Creating container %s' % (name))
        docker_client.create_container(config['image'], name=name, environment=config.get('environment', None))

    if not container_running(name):
        logger.info('Starting container %s' % (name))
        docker_client.start(name, binds=config.get('volumes', None), port_bindings=config.get('ports', None), links=config.get('links', None), restart_policy={ "Name": "always" })
    else: #If the container is actually running
        if restart:
            logger.info('Restarting container %s' % (name))
            docker_client.restart(name, timeout=10)

# Docker API utility functions
def container_exists(name):
    full_name = '/%s' % (name)
    return any(full_name in i['Names'] for i in docker_client.containers(all=True))

def image_exists(name):
    # TODO: append :latest if there is not tag
    return any(name in i['RepoTags'] for i in docker_client.images())

def ensure_image(name):
    if not image_exists(name):
        logger.info('Pulling image %s' % (name))
        docker_client.pull(name)
        logger.info('Finished pulling image %s' % (name))

def configuration_changed(name, new_config):
    container = docker_client.inspect_container(name)

    # TODO: detect more interesting changes
    # container['Config']['Env']
    # container['HostConfig']['PortBindings']
    # volumes
    # links

    return any([
        container['Config']['Image'] != new_config['image']
    ])

def container_running(name):
    container = docker_client.inspect_container(name)
    return container['State']['Running']


# Environment variable functions
def env_function(value):
    fn = value.keys()[0]
    arg = value.values()[0]

    if fn == 'cfn-docker::url':
        return urllib2.urlopen(arg).read()
    else:
        raise Exception('Unknown function: %s' % (fn))

# Sort containers dict in dependency order using t-sort and return a list of (name, config) pairs
def dependency_sort(containers_dict):
    dependencies = []

    # Build dependency DAG for links
    for name, config in containers_dict.items():
        links = config.get('links', {}).keys()
        for link in links:
            dependencies.append((link, name))

    sorted_names = topological_sort(dependencies)

    # sorted_names only includes containers that had dependencies - add any that are missing
    missing_names = list(set(containers_dict.keys()) - set(sorted_names))
    sorted_names.extend(missing_names)

    ordered_configs = map(lambda k: containers_dict[k], sorted_names)

    return zip(sorted_names, ordered_configs)

if __name__ == "__main__":
    main()